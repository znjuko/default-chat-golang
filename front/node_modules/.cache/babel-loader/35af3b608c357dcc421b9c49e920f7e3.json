{"ast":null,"code":"import { __assign } from 'tslib';\nimport { Path } from 'path-parser';\nimport { build, omit, parse } from 'search-params';\n\nvar getMetaFromSegments = function getMetaFromSegments(segments) {\n  var accName = '';\n  return segments.reduce(function (meta, segment) {\n    var _a, _b, _c, _d;\n\n    var urlParams = (_b = (_a = segment.parser) === null || _a === void 0 ? void 0 : _a.urlParams.reduce(function (params, p) {\n      params[p] = 'url';\n      return params;\n    }, {}), _b !== null && _b !== void 0 ? _b : {});\n    var allParams = (_d = (_c = segment.parser) === null || _c === void 0 ? void 0 : _c.queryParams.reduce(function (params, p) {\n      params[p] = 'query';\n      return params;\n    }, urlParams), _d !== null && _d !== void 0 ? _d : {});\n\n    if (segment.name !== undefined) {\n      accName = accName ? accName + '.' + segment.name : segment.name;\n      meta[accName] = allParams;\n    }\n\n    return meta;\n  }, {});\n};\n\nvar buildStateFromMatch = function buildStateFromMatch(match) {\n  if (!match || !match.segments || !match.segments.length) {\n    return null;\n  }\n\n  var name = match.segments.map(function (segment) {\n    return segment.name;\n  }).filter(function (name) {\n    return name;\n  }).join('.');\n  var params = match.params;\n  return {\n    name: name,\n    params: params,\n    meta: getMetaFromSegments(match.segments)\n  };\n};\n\nvar buildPathFromSegments = function buildPathFromSegments(segments, params, options) {\n  if (params === void 0) {\n    params = {};\n  }\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _a = options.queryParamsMode,\n      queryParamsMode = _a === void 0 ? 'default' : _a,\n      _b = options.trailingSlashMode,\n      trailingSlashMode = _b === void 0 ? 'default' : _b;\n  var searchParams = [];\n  var nonSearchParams = [];\n\n  for (var _i = 0, segments_1 = segments; _i < segments_1.length; _i++) {\n    var segment = segments_1[_i];\n    var parser = segment.parser;\n\n    if (parser) {\n      searchParams.push.apply(searchParams, parser.queryParams);\n      nonSearchParams.push.apply(nonSearchParams, parser.urlParams);\n      nonSearchParams.push.apply(nonSearchParams, parser.spatParams);\n    }\n  }\n\n  if (queryParamsMode === 'loose') {\n    var extraParams = Object.keys(params).reduce(function (acc, p) {\n      return searchParams.indexOf(p) === -1 && nonSearchParams.indexOf(p) === -1 ? acc.concat(p) : acc;\n    }, []);\n    searchParams.push.apply(searchParams, extraParams);\n  }\n\n  var searchParamsObject = searchParams.reduce(function (acc, paramName) {\n    if (Object.keys(params).indexOf(paramName) !== -1) {\n      acc[paramName] = params[paramName];\n    }\n\n    return acc;\n  }, {});\n  var searchPart = build(searchParamsObject, options.queryParams);\n  var path = segments.reduce(function (path, segment) {\n    var _a, _b;\n\n    var segmentPath = (_b = (_a = segment.parser) === null || _a === void 0 ? void 0 : _a.build(params, {\n      ignoreSearch: true,\n      queryParams: options.queryParams,\n      urlParamsEncoding: options.urlParamsEncoding\n    }), _b !== null && _b !== void 0 ? _b : '');\n    return segment.absolute ? segmentPath : path + segmentPath;\n  }, '') // remove repeated slashes\n  .replace(/\\/\\/{1,}/g, '/');\n  var finalPath = path;\n\n  if (trailingSlashMode === 'always') {\n    finalPath = /\\/$/.test(path) ? path : path + \"/\";\n  } else if (trailingSlashMode === 'never' && path !== '/') {\n    finalPath = /\\/$/.test(path) ? path.slice(0, -1) : path;\n  }\n\n  return finalPath + (searchPart ? '?' + searchPart : '');\n};\n\nvar getPathFromSegments = function getPathFromSegments(segments) {\n  return segments ? segments.map(function (segment) {\n    return segment.path;\n  }).join('') : null;\n};\n\nvar getPath = function getPath(path) {\n  return path.split('?')[0];\n};\n\nvar getSearch = function getSearch(path) {\n  return path.split('?')[1] || '';\n};\n\nvar matchChildren = function matchChildren(nodes, pathSegment, currentMatch, options, consumedBefore) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _a = options.queryParamsMode,\n      queryParamsMode = _a === void 0 ? 'default' : _a,\n      _b = options.strictTrailingSlash,\n      strictTrailingSlash = _b === void 0 ? false : _b,\n      _c = options.strongMatching,\n      strongMatching = _c === void 0 ? true : _c,\n      _d = options.caseSensitive,\n      caseSensitive = _d === void 0 ? false : _d;\n  var isRoot = nodes.length === 1 && nodes[0].name === '';\n\n  var _loop_1 = function _loop_1(child) {\n    // Partially match path\n    var match = null;\n    var remainingPath = void 0;\n    var segment = pathSegment;\n\n    if (consumedBefore === '/' && child.path === '/') {\n      // when we encounter repeating slashes we add the slash\n      // back to the URL to make it de facto pathless\n      segment = '/' + pathSegment;\n    }\n\n    if (!child.children.length) {\n      match = child.parser.test(segment, {\n        caseSensitive: caseSensitive,\n        strictTrailingSlash: strictTrailingSlash,\n        queryParams: options.queryParams,\n        urlParamsEncoding: options.urlParamsEncoding\n      });\n    }\n\n    if (!match) {\n      match = child.parser.partialTest(segment, {\n        delimited: strongMatching,\n        caseSensitive: caseSensitive,\n        queryParams: options.queryParams,\n        urlParamsEncoding: options.urlParamsEncoding\n      });\n    }\n\n    if (match) {\n      // Remove consumed segment from path\n      var consumedPath = child.parser.build(match, {\n        ignoreSearch: true,\n        urlParamsEncoding: options.urlParamsEncoding\n      });\n\n      if (!strictTrailingSlash && !child.children.length) {\n        consumedPath = consumedPath.replace(/\\/$/, '');\n      } // Can't create a regexp from the path because it might contain a\n      // regexp character.\n\n\n      if (segment.toLowerCase().indexOf(consumedPath.toLowerCase()) === 0) {\n        remainingPath = segment.slice(consumedPath.length);\n      } else {\n        remainingPath = segment;\n      }\n\n      if (!strictTrailingSlash && !child.children.length) {\n        remainingPath = remainingPath.replace(/^\\/\\?/, '?');\n      }\n\n      var querystring = omit(getSearch(segment.replace(consumedPath, '')), child.parser.queryParams, options.queryParams).querystring;\n      remainingPath = getPath(remainingPath) + (querystring ? \"?\" + querystring : '');\n\n      if (!strictTrailingSlash && !isRoot && remainingPath === '/' && !/\\/$/.test(consumedPath)) {\n        remainingPath = '';\n      }\n\n      currentMatch.segments.push(child);\n      Object.keys(match).forEach(function (param) {\n        return currentMatch.params[param] = match[param];\n      });\n\n      if (!isRoot && !remainingPath.length) {\n        return {\n          value: currentMatch\n        };\n      }\n\n      if (!isRoot && queryParamsMode !== 'strict' && remainingPath.indexOf('?') === 0) {\n        // unmatched queryParams in non strict mode\n        var remainingQueryParams_1 = parse(remainingPath.slice(1), options.queryParams);\n        Object.keys(remainingQueryParams_1).forEach(function (name) {\n          return currentMatch.params[name] = remainingQueryParams_1[name];\n        });\n        return {\n          value: currentMatch\n        };\n      } // Continue matching on non absolute children\n\n\n      var children = child.getNonAbsoluteChildren(); // If no children to match against but unmatched path left\n\n      if (!children.length) {\n        return {\n          value: null\n        };\n      }\n\n      return {\n        value: matchChildren(children, remainingPath, currentMatch, options, consumedPath)\n      };\n    }\n  }; // for (child of node.children) {\n\n\n  for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n    var child = nodes_1[_i];\n\n    var state_1 = _loop_1(child);\n\n    if (typeof state_1 === \"object\") return state_1.value;\n  }\n\n  return null;\n};\n\nfunction sortChildren(children) {\n  var originalChildren = children.slice(0);\n  return children.sort(sortPredicate(originalChildren));\n}\n\nvar sortPredicate = function sortPredicate(originalChildren) {\n  return function (left, right) {\n    var _a, _b, _c, _d, _e, _f;\n\n    var leftPath = left.path.replace(/<.*?>/g, '').split('?')[0].replace(/(.+)\\/$/, '$1');\n    var rightPath = right.path.replace(/<.*?>/g, '').split('?')[0].replace(/(.+)\\/$/, '$1'); // '/' last\n\n    if (leftPath === '/') {\n      return 1;\n    }\n\n    if (rightPath === '/') {\n      return -1;\n    } // Spat params last\n\n\n    if ((_a = left.parser) === null || _a === void 0 ? void 0 : _a.hasSpatParam) {\n      return 1;\n    }\n\n    if ((_b = right.parser) === null || _b === void 0 ? void 0 : _b.hasSpatParam) {\n      return -1;\n    } // No spat, number of segments (less segments last)\n\n\n    var leftSegments = (leftPath.match(/\\//g) || []).length;\n    var rightSegments = (rightPath.match(/\\//g) || []).length;\n\n    if (leftSegments < rightSegments) {\n      return 1;\n    }\n\n    if (leftSegments > rightSegments) {\n      return -1;\n    } // Same number of segments, number of URL params ascending\n\n\n    var leftParamsCount = (_d = (_c = left.parser) === null || _c === void 0 ? void 0 : _c.urlParams.length, _d !== null && _d !== void 0 ? _d : 0);\n    var rightParamsCount = (_f = (_e = right.parser) === null || _e === void 0 ? void 0 : _e.urlParams.length, _f !== null && _f !== void 0 ? _f : 0);\n\n    if (leftParamsCount < rightParamsCount) {\n      return -1;\n    }\n\n    if (leftParamsCount > rightParamsCount) {\n      return 1;\n    } // Same number of segments and params, last segment length descending\n\n\n    var leftParamLength = (leftPath.split('/').slice(-1)[0] || '').length;\n    var rightParamLength = (rightPath.split('/').slice(-1)[0] || '').length;\n\n    if (leftParamLength < rightParamLength) {\n      return 1;\n    }\n\n    if (leftParamLength > rightParamLength) {\n      return -1;\n    } // Same last segment length, preserve definition order. Note that we\n    // cannot just return 0, as sort is not guaranteed to be a stable sort.\n\n\n    return originalChildren.indexOf(left) - originalChildren.indexOf(right);\n  };\n};\n\nvar RouteNode =\n/*#__PURE__*/\n\n/** @class */\nfunction () {\n  function RouteNode(name, path, childRoutes, options) {\n    if (name === void 0) {\n      name = '';\n    }\n\n    if (path === void 0) {\n      path = '';\n    }\n\n    if (childRoutes === void 0) {\n      childRoutes = [];\n    }\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.name = name;\n    this.absolute = /^~/.test(path);\n    this.path = this.absolute ? path.slice(1) : path;\n    this.parser = this.path ? new Path(this.path) : null;\n    this.children = [];\n    this.parent = options.parent;\n    this.checkParents();\n    this.add(childRoutes, options.onAdd, options.finalSort ? false : options.sort !== false);\n\n    if (options.finalSort) {\n      this.sortDescendants();\n    }\n\n    return this;\n  }\n\n  RouteNode.prototype.getParentSegments = function (segments) {\n    if (segments === void 0) {\n      segments = [];\n    }\n\n    return this.parent && this.parent.parser ? this.parent.getParentSegments(segments.concat(this.parent)) : segments.reverse();\n  };\n\n  RouteNode.prototype.setParent = function (parent) {\n    this.parent = parent;\n    this.checkParents();\n  };\n\n  RouteNode.prototype.setPath = function (path) {\n    if (path === void 0) {\n      path = '';\n    }\n\n    this.path = path;\n    this.parser = path ? new Path(path) : null;\n  };\n\n  RouteNode.prototype.add = function (route, cb, sort) {\n    var _this = this;\n\n    if (sort === void 0) {\n      sort = true;\n    }\n\n    if (route === undefined || route === null) {\n      return this;\n    }\n\n    if (route instanceof Array) {\n      route.forEach(function (r) {\n        return _this.add(r, cb, sort);\n      });\n      return this;\n    }\n\n    if (!(route instanceof RouteNode) && !(route instanceof Object)) {\n      throw new Error('RouteNode.add() expects routes to be an Object or an instance of RouteNode.');\n    } else if (route instanceof RouteNode) {\n      route.setParent(this);\n      this.addRouteNode(route, sort);\n    } else {\n      if (!route.name || !route.path) {\n        throw new Error('RouteNode.add() expects routes to have a name and a path defined.');\n      }\n\n      var routeNode = new RouteNode(route.name, route.path, route.children, {\n        finalSort: false,\n        onAdd: cb,\n        parent: this,\n        sort: sort\n      });\n      var fullName = routeNode.getParentSegments([routeNode]).map(function (_) {\n        return _.name;\n      }).join('.');\n\n      if (cb) {\n        cb(__assign(__assign({}, route), {\n          name: fullName\n        }));\n      }\n\n      this.addRouteNode(routeNode, sort);\n    }\n\n    return this;\n  };\n\n  RouteNode.prototype.addNode = function (name, path) {\n    this.add(new RouteNode(name, path));\n    return this;\n  };\n\n  RouteNode.prototype.getPath = function (routeName) {\n    var segmentsByName = this.getSegmentsByName(routeName);\n    return segmentsByName ? getPathFromSegments(segmentsByName) : null;\n  };\n\n  RouteNode.prototype.getNonAbsoluteChildren = function () {\n    return this.children.filter(function (child) {\n      return !child.absolute;\n    });\n  };\n\n  RouteNode.prototype.sortChildren = function () {\n    if (this.children.length) {\n      sortChildren(this.children);\n    }\n  };\n\n  RouteNode.prototype.sortDescendants = function () {\n    this.sortChildren();\n    this.children.forEach(function (child) {\n      return child.sortDescendants();\n    });\n  };\n\n  RouteNode.prototype.buildPath = function (routeName, params, options) {\n    if (params === void 0) {\n      params = {};\n    }\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    var segments = this.getSegmentsByName(routeName);\n\n    if (!segments) {\n      throw new Error(\"[route-node][buildPath] '{routeName}' is not defined\");\n    }\n\n    return buildPathFromSegments(segments, params, options);\n  };\n\n  RouteNode.prototype.buildState = function (name, params) {\n    if (params === void 0) {\n      params = {};\n    }\n\n    var segments = this.getSegmentsByName(name);\n\n    if (!segments || !segments.length) {\n      return null;\n    }\n\n    return {\n      name: name,\n      params: params,\n      meta: getMetaFromSegments(segments)\n    };\n  };\n\n  RouteNode.prototype.matchPath = function (path, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    if (path === '' && !options.strictTrailingSlash) {\n      path = '/';\n    }\n\n    var match = this.getSegmentsMatchingPath(path, options);\n\n    if (!match) {\n      return null;\n    }\n\n    var matchedSegments = match.segments;\n\n    if (matchedSegments[0].absolute) {\n      var firstSegmentParams = matchedSegments[0].getParentSegments();\n      matchedSegments.reverse();\n      matchedSegments.push.apply(matchedSegments, firstSegmentParams);\n      matchedSegments.reverse();\n    }\n\n    var lastSegment = matchedSegments[matchedSegments.length - 1];\n    var lastSegmentSlashChild = lastSegment.findSlashChild();\n\n    if (lastSegmentSlashChild) {\n      matchedSegments.push(lastSegmentSlashChild);\n    }\n\n    return buildStateFromMatch(match);\n  };\n\n  RouteNode.prototype.addRouteNode = function (route, sort) {\n    if (sort === void 0) {\n      sort = true;\n    }\n\n    var names = route.name.split('.');\n\n    if (names.length === 1) {\n      // Check duplicated routes\n      if (this.children.map(function (child) {\n        return child.name;\n      }).indexOf(route.name) !== -1) {\n        throw new Error(\"Alias \\\"\" + route.name + \"\\\" is already defined in route node\");\n      } // Check duplicated paths\n\n\n      if (this.children.map(function (child) {\n        return child.path;\n      }).indexOf(route.path) !== -1) {\n        throw new Error(\"Path \\\"\" + route.path + \"\\\" is already defined in route node\");\n      }\n\n      this.children.push(route);\n\n      if (sort) {\n        this.sortChildren();\n      }\n    } else {\n      // Locate parent node\n      var segments = this.getSegmentsByName(names.slice(0, -1).join('.'));\n\n      if (segments) {\n        route.name = names[names.length - 1];\n        segments[segments.length - 1].add(route);\n      } else {\n        throw new Error(\"Could not add route named '\" + route.name + \"', parent is missing.\");\n      }\n    }\n\n    return this;\n  };\n\n  RouteNode.prototype.checkParents = function () {\n    if (this.absolute && this.hasParentsParams()) {\n      throw new Error('[RouteNode] A RouteNode with an abolute path cannot have parents with route parameters');\n    }\n  };\n\n  RouteNode.prototype.hasParentsParams = function () {\n    if (this.parent && this.parent.parser) {\n      var parser = this.parent.parser;\n      var hasParams = parser.hasUrlParams || parser.hasSpatParam || parser.hasMatrixParams || parser.hasQueryParams;\n      return hasParams || this.parent.hasParentsParams();\n    }\n\n    return false;\n  };\n\n  RouteNode.prototype.findAbsoluteChildren = function () {\n    return this.children.reduce(function (absoluteChildren, child) {\n      return absoluteChildren.concat(child.absolute ? child : []).concat(child.findAbsoluteChildren());\n    }, []);\n  };\n\n  RouteNode.prototype.findSlashChild = function () {\n    var slashChildren = this.getNonAbsoluteChildren().filter(function (child) {\n      return child.parser && /^\\/(\\?|$)/.test(child.parser.path);\n    });\n    return slashChildren[0];\n  };\n\n  RouteNode.prototype.getSegmentsByName = function (routeName) {\n    var findSegmentByName = function findSegmentByName(name, routes) {\n      var filteredRoutes = routes.filter(function (r) {\n        return r.name === name;\n      });\n      return filteredRoutes.length ? filteredRoutes[0] : undefined;\n    };\n\n    var segments = [];\n    var routes = this.parser ? [this] : this.children;\n    var names = (this.parser ? [''] : []).concat(routeName.split('.'));\n    var matched = names.every(function (name) {\n      var segment = findSegmentByName(name, routes);\n\n      if (segment) {\n        routes = segment.children;\n        segments.push(segment);\n        return true;\n      }\n\n      return false;\n    });\n    return matched ? segments : null;\n  };\n\n  RouteNode.prototype.getSegmentsMatchingPath = function (path, options) {\n    var topLevelNodes = this.parser ? [this] : this.children;\n    var startingNodes = topLevelNodes.reduce(function (nodes, node) {\n      return nodes.concat(node, node.findAbsoluteChildren());\n    }, []);\n    var currentMatch = {\n      segments: [],\n      params: {}\n    };\n    var finalMatch = matchChildren(startingNodes, path, currentMatch, options);\n\n    if (finalMatch && finalMatch.segments.length === 1 && finalMatch.segments[0].name === '') {\n      return null;\n    }\n\n    return finalMatch;\n  };\n\n  return RouteNode;\n}();\n\nexport { RouteNode };","map":{"version":3,"sources":["../src/helpers.ts","../src/matchChildren.ts","../src/sortChildren.ts","../src/RouteNode.ts"],"names":["getMetaFromSegments","accName","urlParams","segment","parser","reduce","params","allParams","queryParams","meta","buildStateFromMatch","match","name","buildPathFromSegments","options","_a","_b","searchParams","nonSearchParams","queryParamsMode","extraParams","acc","searchParamsObject","Object","searchPart","build","path","segmentPath","ignoreSearch","urlParamsEncoding","finalPath","trailingSlashMode","getPathFromSegments","segments","getPath","getSearch","matchChildren","_c","_d","isRoot","nodes","child","remainingPath","consumedBefore","caseSensitive","strictTrailingSlash","delimited","consumedPath","querystring","currentMatch","remainingQueryParams_1","parse","children","sortChildren","originalChildren","sortPredicate","leftPath","left","rightPath","right","leftSegments","rightSegments","leftParamsCount","length","rightParamsCount","leftParamLength","rightParamLength","childRoutes","RouteNode","sort","route","_this","routeNode","finalSort","onAdd","parent","fullName","_","cb","segmentsByName","matchedSegments","firstSegmentParams","lastSegment","lastSegmentSlashChild","names","hasParams","absoluteChildren","slashChildren","findSegmentByName","filteredRoutes","r","routes","routeName","matched","topLevelNodes","startingNodes","node","finalMatch"],"mappings":"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","sourcesContent":["import { build } from 'search-params'\nimport {\n  BuildOptions,\n  MatchResponse,\n  RouteNode,\n  RouteNodeState,\n  RouteNodeStateMeta\n} from './RouteNode'\n\nexport const getMetaFromSegments = (\n  segments: RouteNode[]\n): RouteNodeStateMeta => {\n  let accName = ''\n\n  return segments.reduce<RouteNodeStateMeta>((meta, segment) => {\n    const urlParams =\n      segment.parser?.urlParams.reduce<Record<string, any>>((params, p) => {\n        params[p] = 'url'\n        return params\n      }, {}) ?? {}\n\n    const allParams =\n      segment.parser?.queryParams.reduce<Record<string, any>>((params, p) => {\n        params[p] = 'query'\n        return params\n      }, urlParams) ?? {}\n\n    if (segment.name !== undefined) {\n      accName = accName ? accName + '.' + segment.name : segment.name\n      meta[accName] = allParams\n    }\n    return meta\n  }, {})\n}\n\nexport const buildStateFromMatch = (\n  match: MatchResponse\n): RouteNodeState | null => {\n  if (!match || !match.segments || !match.segments.length) {\n    return null\n  }\n\n  const name = match.segments\n    .map(segment => segment.name)\n    .filter(name => name)\n    .join('.')\n  const params = match.params\n\n  return {\n    name,\n    params,\n    meta: getMetaFromSegments(match.segments)\n  }\n}\n\nexport const buildPathFromSegments = (\n  segments: RouteNode[],\n  params: Record<string, any> = {},\n  options: BuildOptions = {}\n) => {\n  const { queryParamsMode = 'default', trailingSlashMode = 'default' } = options\n  const searchParams: string[] = []\n  const nonSearchParams: string[] = []\n\n  for (const segment of segments) {\n    const { parser } = segment\n\n    if (parser) {\n      searchParams.push(...parser.queryParams)\n      nonSearchParams.push(...parser.urlParams)\n      nonSearchParams.push(...parser.spatParams)\n    }\n  }\n\n  if (queryParamsMode === 'loose') {\n    const extraParams = Object.keys(params).reduce<string[]>(\n      (acc, p) =>\n        searchParams.indexOf(p) === -1 && nonSearchParams.indexOf(p) === -1\n          ? acc.concat(p)\n          : acc,\n      []\n    )\n    searchParams.push(...extraParams)\n  }\n\n  const searchParamsObject = searchParams.reduce<Record<string, any>>(\n    (acc, paramName) => {\n      if (Object.keys(params).indexOf(paramName) !== -1) {\n        acc[paramName] = params[paramName]\n      }\n\n      return acc\n    },\n    {}\n  )\n\n  const searchPart = build(searchParamsObject, options.queryParams)\n\n  const path = segments\n    .reduce<string>((path, segment) => {\n      const segmentPath =\n        segment.parser?.build(params, {\n          ignoreSearch: true,\n          queryParams: options.queryParams,\n          urlParamsEncoding: options.urlParamsEncoding\n        }) ?? ''\n\n      return segment.absolute ? segmentPath : path + segmentPath\n    }, '')\n    // remove repeated slashes\n    .replace(/\\/\\/{1,}/g, '/')\n\n  let finalPath = path\n\n  if (trailingSlashMode === 'always') {\n    finalPath = /\\/$/.test(path) ? path : `${path}/`\n  } else if (trailingSlashMode === 'never' && path !== '/') {\n    finalPath = /\\/$/.test(path) ? path.slice(0, -1) : path\n  }\n\n  return finalPath + (searchPart ? '?' + searchPart : '')\n}\n\nexport const getPathFromSegments = (segments: RouteNode[]): string | null =>\n  segments ? segments.map(segment => segment.path).join('') : null\n","import { omit, parse } from 'search-params'\nimport { MatchOptions, MatchResponse, RouteNode } from './RouteNode'\nimport { TestMatch } from 'path-parser'\n\nconst getPath = (path: string): string => path.split('?')[0]\n\nconst getSearch = (path: string): string => path.split('?')[1] || ''\n\nconst matchChildren = (\n  nodes: RouteNode[],\n  pathSegment: string,\n  currentMatch: MatchResponse,\n  options: MatchOptions = {},\n  consumedBefore?: string\n): MatchResponse | null => {\n  const {\n    queryParamsMode = 'default',\n    strictTrailingSlash = false,\n    strongMatching = true,\n    caseSensitive = false\n  } = options\n  const isRoot = nodes.length === 1 && nodes[0].name === ''\n  // for (child of node.children) {\n  for (const child of nodes) {\n    // Partially match path\n    let match: TestMatch | null = null\n    let remainingPath\n    let segment = pathSegment\n\n    if (consumedBefore === '/' && child.path === '/') {\n      // when we encounter repeating slashes we add the slash\n      // back to the URL to make it de facto pathless\n      segment = '/' + pathSegment\n    }\n\n    if (!child.children.length) {\n      match = child.parser!.test(segment, {\n        caseSensitive,\n        strictTrailingSlash,\n        queryParams: options.queryParams,\n        urlParamsEncoding: options.urlParamsEncoding\n      })\n    }\n\n    if (!match) {\n      match = child.parser!.partialTest(segment, {\n        delimited: strongMatching,\n        caseSensitive,\n        queryParams: options.queryParams,\n        urlParamsEncoding: options.urlParamsEncoding\n      })\n    }\n\n    if (match) {\n      // Remove consumed segment from path\n      let consumedPath = child.parser!.build(match, {\n        ignoreSearch: true,\n        urlParamsEncoding: options.urlParamsEncoding\n      })\n\n      if (!strictTrailingSlash && !child.children.length) {\n        consumedPath = consumedPath.replace(/\\/$/, '')\n      }\n\n      // Can't create a regexp from the path because it might contain a\n      // regexp character.\n      if (segment.toLowerCase().indexOf(consumedPath.toLowerCase()) === 0) {\n        remainingPath = segment.slice(consumedPath.length)\n      } else {\n        remainingPath = segment\n      }\n\n      if (!strictTrailingSlash && !child.children.length) {\n        remainingPath = remainingPath.replace(/^\\/\\?/, '?')\n      }\n\n      const { querystring } = omit(\n        getSearch(segment.replace(consumedPath, '')),\n        child.parser!.queryParams,\n        options.queryParams\n      )\n      remainingPath =\n        getPath(remainingPath) + (querystring ? `?${querystring}` : '')\n      if (\n        !strictTrailingSlash &&\n        !isRoot &&\n        remainingPath === '/' &&\n        !/\\/$/.test(consumedPath)\n      ) {\n        remainingPath = ''\n      }\n\n      currentMatch.segments.push(child)\n      Object.keys(match).forEach(\n        param => (currentMatch.params[param] = match![param])\n      )\n\n      if (!isRoot && !remainingPath.length) {\n        // fully matched\n        return currentMatch\n      }\n      if (\n        !isRoot &&\n        queryParamsMode !== 'strict' &&\n        remainingPath.indexOf('?') === 0\n      ) {\n        // unmatched queryParams in non strict mode\n        const remainingQueryParams = parse(\n          remainingPath.slice(1),\n          options.queryParams\n        ) as any\n\n        Object.keys(remainingQueryParams).forEach(\n          name => (currentMatch.params[name] = remainingQueryParams[name])\n        )\n        return currentMatch\n      }\n      // Continue matching on non absolute children\n      const children = child.getNonAbsoluteChildren()\n      // If no children to match against but unmatched path left\n      if (!children.length) {\n        return null\n      }\n      // Else: remaining path and children\n      return matchChildren(\n        children,\n        remainingPath,\n        currentMatch,\n        options,\n        consumedPath\n      )\n    }\n  }\n\n  return null\n}\n\nexport default matchChildren\n","import { RouteNode } from './RouteNode'\n\nexport default function sortChildren(children: RouteNode[]) {\n  const originalChildren = children.slice(0)\n\n  return children.sort(sortPredicate(originalChildren))\n}\n\nconst sortPredicate = (originalChildren: RouteNode[]) => (\n  left: RouteNode,\n  right: RouteNode\n): number => {\n  const leftPath = left.path\n    .replace(/<.*?>/g, '')\n    .split('?')[0]\n    .replace(/(.+)\\/$/, '$1')\n  const rightPath = right.path\n    .replace(/<.*?>/g, '')\n    .split('?')[0]\n    .replace(/(.+)\\/$/, '$1')\n\n  // '/' last\n  if (leftPath === '/') {\n    return 1\n  }\n  if (rightPath === '/') {\n    return -1\n  }\n  // Spat params last\n  if (left.parser?.hasSpatParam) {\n    return 1\n  }\n  if (right.parser?.hasSpatParam) {\n    return -1\n  }\n  // No spat, number of segments (less segments last)\n  const leftSegments = (leftPath.match(/\\//g) || []).length\n  const rightSegments = (rightPath.match(/\\//g) || []).length\n  if (leftSegments < rightSegments) {\n    return 1\n  }\n  if (leftSegments > rightSegments) {\n    return -1\n  }\n  // Same number of segments, number of URL params ascending\n  const leftParamsCount = left.parser?.urlParams.length ?? 0\n  const rightParamsCount = right.parser?.urlParams.length ?? 0\n  if (leftParamsCount < rightParamsCount) {\n    return -1\n  }\n  if (leftParamsCount > rightParamsCount) {\n    return 1\n  }\n  // Same number of segments and params, last segment length descending\n  const leftParamLength = (leftPath.split('/').slice(-1)[0] || '').length\n  const rightParamLength = (rightPath.split('/').slice(-1)[0] || '').length\n  if (leftParamLength < rightParamLength) {\n    return 1\n  }\n  if (leftParamLength > rightParamLength) {\n    return -1\n  }\n  // Same last segment length, preserve definition order. Note that we\n  // cannot just return 0, as sort is not guaranteed to be a stable sort.\n  return originalChildren.indexOf(left) - originalChildren.indexOf(right)\n}\n","import { Path, URLParamsEncodingType } from 'path-parser'\nimport { IOptions as QueryParamsOptions } from 'search-params'\n\nimport {\n  buildPathFromSegments,\n  buildStateFromMatch,\n  getMetaFromSegments,\n  getPathFromSegments\n} from './helpers'\nimport matchChildren from './matchChildren'\nimport sortChildren from './sortChildren'\n\nexport interface RouteDefinition {\n  name: string\n  path: string\n  [key: string]: any\n}\nexport type Route = RouteNode | RouteDefinition\nexport type Callback = (...args: any[]) => void\nexport type TrailingSlashMode = 'default' | 'never' | 'always'\nexport type QueryParamsMode = 'default' | 'strict' | 'loose'\n\nexport interface BuildOptions {\n  trailingSlashMode?: TrailingSlashMode\n  queryParamsMode?: QueryParamsMode\n  queryParams?: QueryParamsOptions\n  urlParamsEncoding?: URLParamsEncodingType\n}\n\nexport interface MatchOptions {\n  caseSensitive?: boolean\n  trailingSlashMode?: TrailingSlashMode\n  queryParamsMode?: QueryParamsMode\n  queryParams?: QueryParamsOptions\n  strictTrailingSlash?: boolean\n  strongMatching?: boolean\n  urlParamsEncoding?: URLParamsEncodingType\n}\n\nexport { QueryParamsOptions }\n\nexport interface MatchResponse {\n  segments: RouteNode[]\n  params: Record<string, any>\n}\n\nexport interface RouteNodeStateMeta {\n  [routeName: string]: {\n    [routeParams: string]: 'query' | 'url'\n  }\n}\n\nexport interface RouteNodeState {\n  name: string\n  params: Record<string, any>\n  meta: RouteNodeStateMeta\n}\n\nexport interface RouteNodeOptions {\n  finalSort?: boolean\n  onAdd?: Callback\n  parent?: RouteNode\n  sort?: boolean\n}\n\nexport class RouteNode {\n  public name: string\n  public absolute: boolean\n  public path: string\n  public parser: Path | null\n  public children: RouteNode[]\n  public parent?: RouteNode\n\n  constructor(\n    name: string = '',\n    path: string = '',\n    childRoutes: Route[] = [],\n    options: RouteNodeOptions = {}\n  ) {\n    this.name = name\n    this.absolute = /^~/.test(path)\n    this.path = this.absolute ? path.slice(1) : path\n\n    this.parser = this.path ? new Path(this.path) : null\n    this.children = []\n    this.parent = options.parent\n\n    this.checkParents()\n\n    this.add(\n      childRoutes,\n      options.onAdd,\n      options.finalSort ? false : options.sort !== false\n    )\n\n    if (options.finalSort) {\n      this.sortDescendants()\n    }\n\n    return this\n  }\n\n  public getParentSegments(segments: RouteNode[] = []): RouteNode[] {\n    return this.parent && this.parent.parser\n      ? this.parent.getParentSegments(segments.concat(this.parent))\n      : segments.reverse()\n  }\n\n  public setParent(parent: RouteNode) {\n    this.parent = parent\n    this.checkParents()\n  }\n\n  public setPath(path: string = '') {\n    this.path = path\n    this.parser = path ? new Path(path) : null\n  }\n\n  public add(\n    route: Route | Route[],\n    cb?: Callback,\n    sort: boolean = true\n  ): this {\n    if (route === undefined || route === null) {\n      return this\n    }\n\n    if (route instanceof Array) {\n      route.forEach(r => this.add(r, cb, sort))\n      return this\n    }\n\n    if (!(route instanceof RouteNode) && !(route instanceof Object)) {\n      throw new Error(\n        'RouteNode.add() expects routes to be an Object or an instance of RouteNode.'\n      )\n    } else if (route instanceof RouteNode) {\n      route.setParent(this)\n      this.addRouteNode(route, sort)\n    } else {\n      if (!route.name || !route.path) {\n        throw new Error(\n          'RouteNode.add() expects routes to have a name and a path defined.'\n        )\n      }\n\n      const routeNode = new RouteNode(route.name, route.path, route.children, {\n        finalSort: false,\n        onAdd: cb,\n        parent: this,\n        sort\n      })\n      const fullName = routeNode\n        .getParentSegments([routeNode])\n        .map(_ => _.name)\n        .join('.')\n      if (cb) {\n        cb({\n          ...route,\n          name: fullName\n        })\n      }\n      this.addRouteNode(routeNode, sort)\n    }\n\n    return this\n  }\n\n  public addNode(name: string, path: string) {\n    this.add(new RouteNode(name, path))\n    return this\n  }\n\n  public getPath(routeName: string): string | null {\n    const segmentsByName = this.getSegmentsByName(routeName)\n\n    return segmentsByName ? getPathFromSegments(segmentsByName) : null\n  }\n\n  public getNonAbsoluteChildren(): RouteNode[] {\n    return this.children.filter(child => !child.absolute)\n  }\n\n  public sortChildren() {\n    if (this.children.length) {\n      sortChildren(this.children)\n    }\n  }\n\n  public sortDescendants() {\n    this.sortChildren()\n    this.children.forEach(child => child.sortDescendants())\n  }\n\n  public buildPath(\n    routeName: string,\n    params: Record<string, any> = {},\n    options: BuildOptions = {}\n  ): string {\n    const segments = this.getSegmentsByName(routeName)\n\n    if (!segments) {\n      throw new Error(`[route-node][buildPath] '{routeName}' is not defined`)\n    }\n\n    return buildPathFromSegments(segments, params, options)\n  }\n\n  public buildState(\n    name: string,\n    params: Record<string, any> = {}\n  ): RouteNodeState | null {\n    const segments = this.getSegmentsByName(name)\n\n    if (!segments || !segments.length) {\n      return null\n    }\n\n    return {\n      name,\n      params,\n      meta: getMetaFromSegments(segments)\n    }\n  }\n\n  public matchPath(\n    path: string,\n    options: MatchOptions = {}\n  ): RouteNodeState | null {\n    if (path === '' && !options.strictTrailingSlash) {\n      path = '/'\n    }\n\n    const match = this.getSegmentsMatchingPath(path, options)\n\n    if (!match) {\n      return null\n    }\n\n    const matchedSegments = match.segments\n\n    if (matchedSegments[0].absolute) {\n      const firstSegmentParams = matchedSegments[0].getParentSegments()\n\n      matchedSegments.reverse()\n      matchedSegments.push(...firstSegmentParams)\n      matchedSegments.reverse()\n    }\n\n    const lastSegment = matchedSegments[matchedSegments.length - 1]\n    const lastSegmentSlashChild = lastSegment.findSlashChild()\n\n    if (lastSegmentSlashChild) {\n      matchedSegments.push(lastSegmentSlashChild)\n    }\n\n    return buildStateFromMatch(match)\n  }\n\n  private addRouteNode(route: RouteNode, sort: boolean = true): this {\n    const names = route.name.split('.')\n\n    if (names.length === 1) {\n      // Check duplicated routes\n      if (this.children.map(child => child.name).indexOf(route.name) !== -1) {\n        throw new Error(\n          `Alias \"${route.name}\" is already defined in route node`\n        )\n      }\n\n      // Check duplicated paths\n      if (this.children.map(child => child.path).indexOf(route.path) !== -1) {\n        throw new Error(`Path \"${route.path}\" is already defined in route node`)\n      }\n\n      this.children.push(route)\n\n      if (sort) {\n        this.sortChildren()\n      }\n    } else {\n      // Locate parent node\n      const segments = this.getSegmentsByName(names.slice(0, -1).join('.'))\n      if (segments) {\n        route.name = names[names.length - 1]\n        segments[segments.length - 1].add(route)\n      } else {\n        throw new Error(\n          `Could not add route named '${route.name}', parent is missing.`\n        )\n      }\n    }\n\n    return this\n  }\n\n  private checkParents() {\n    if (this.absolute && this.hasParentsParams()) {\n      throw new Error(\n        '[RouteNode] A RouteNode with an abolute path cannot have parents with route parameters'\n      )\n    }\n  }\n\n  private hasParentsParams(): boolean {\n    if (this.parent && this.parent.parser) {\n      const parser = this.parent.parser\n      const hasParams =\n        parser.hasUrlParams ||\n        parser.hasSpatParam ||\n        parser.hasMatrixParams ||\n        parser.hasQueryParams\n\n      return hasParams || this.parent.hasParentsParams()\n    }\n\n    return false\n  }\n\n  private findAbsoluteChildren(): RouteNode[] {\n    return this.children.reduce<RouteNode[]>(\n      (absoluteChildren, child) =>\n        absoluteChildren\n          .concat(child.absolute ? child : [])\n          .concat(child.findAbsoluteChildren()),\n      []\n    )\n  }\n\n  private findSlashChild(): RouteNode | undefined {\n    const slashChildren = this.getNonAbsoluteChildren().filter(\n      child => child.parser && /^\\/(\\?|$)/.test(child.parser.path)\n    )\n\n    return slashChildren[0]\n  }\n\n  private getSegmentsByName(routeName: string): RouteNode[] | null {\n    const findSegmentByName = (name: string, routes: RouteNode[]) => {\n      const filteredRoutes = routes.filter(r => r.name === name)\n      return filteredRoutes.length ? filteredRoutes[0] : undefined\n    }\n    const segments: RouteNode[] = []\n    let routes = this.parser ? [this] : this.children\n    const names = (this.parser ? [''] : []).concat(routeName.split('.'))\n\n    const matched = names.every(name => {\n      const segment = findSegmentByName(name, routes)\n      if (segment) {\n        routes = segment.children\n        segments.push(segment)\n        return true\n      }\n      return false\n    })\n\n    return matched ? segments : null\n  }\n\n  private getSegmentsMatchingPath(\n    path: string,\n    options: MatchOptions\n  ): MatchResponse | null {\n    const topLevelNodes = this.parser ? [this] : this.children\n    const startingNodes = topLevelNodes.reduce<RouteNode[]>(\n      (nodes, node) => nodes.concat(node, node.findAbsoluteChildren()),\n      []\n    )\n\n    const currentMatch = {\n      segments: [],\n      params: {}\n    }\n\n    const finalMatch = matchChildren(startingNodes, path, currentMatch, options)\n\n    if (\n      finalMatch &&\n      finalMatch.segments.length === 1 &&\n      finalMatch.segments[0].name === ''\n    ) {\n      return null\n    }\n\n    return finalMatch\n  }\n}\n"]},"metadata":{},"sourceType":"module"}