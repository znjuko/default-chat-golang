{"ast":null,"code":"import { __assign } from 'tslib';\nimport { parse, build } from 'search-params';\n/**\r\n * We encode using encodeURIComponent but we want to\r\n * preserver certain characters which are commonly used\r\n * (sub delimiters and ':')\r\n *\r\n * https://www.ietf.org/rfc/rfc3986.txt\r\n *\r\n * reserved    = gen-delims / sub-delims\r\n *\r\n * gen-delims  = \":\" / \"/\" / \"?\" / \"#\" / \"[\" / \"]\" / \"@\"\r\n *\r\n * sub-delims  = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\r\n              / \"*\" / \"+\" / \",\" / \";\" / \"=\"\r\n */\n\nvar excludeSubDelimiters = /[^!$'()*+,;|:]/g;\n\nvar encodeURIComponentExcludingSubDelims = function encodeURIComponentExcludingSubDelims(segment) {\n  return segment.replace(excludeSubDelimiters, function (match) {\n    return encodeURIComponent(match);\n  });\n};\n\nvar encodingMethods = {\n  \"default\": encodeURIComponentExcludingSubDelims,\n  uri: encodeURI,\n  uriComponent: encodeURIComponent,\n  none: function none(val) {\n    return val;\n  },\n  legacy: encodeURI\n};\nvar decodingMethods = {\n  \"default\": decodeURIComponent,\n  uri: decodeURI,\n  uriComponent: decodeURIComponent,\n  none: function none(val) {\n    return val;\n  },\n  legacy: decodeURIComponent\n};\n\nvar encodeParam = function encodeParam(param, encoding, isSpatParam) {\n  var encoder = encodingMethods[encoding] || encodeURIComponentExcludingSubDelims;\n\n  if (isSpatParam) {\n    return String(param).split('/').map(encoder).join('/');\n  }\n\n  return encoder(String(param));\n};\n\nvar decodeParam = function decodeParam(param, encoding) {\n  return (decodingMethods[encoding] || decodeURIComponent)(param);\n};\n\nvar defaultOrConstrained = function defaultOrConstrained(match) {\n  return '(' + (match ? match.replace(/(^<|>$)/g, '') : \"[a-zA-Z0-9-_.~%':|=+\\\\*@$]+\") + ')';\n};\n\nvar rules = [{\n  name: 'url-parameter',\n  pattern: /^:([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})(<(.+?)>)?/,\n  regex: function regex(match) {\n    return new RegExp(defaultOrConstrained(match[2]));\n  }\n}, {\n  name: 'url-parameter-splat',\n  pattern: /^\\*([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})/,\n  regex: /([^?]*)/\n}, {\n  name: 'url-parameter-matrix',\n  pattern: /^;([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})(<(.+?)>)?/,\n  regex: function regex(match) {\n    return new RegExp(';' + match[1] + '=' + defaultOrConstrained(match[2]));\n  }\n}, {\n  name: 'query-parameter',\n  pattern: /^(?:\\?|&)(?::)?([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})/\n}, {\n  name: 'delimiter',\n  pattern: /^(\\/|\\?)/,\n  regex: function regex(match) {\n    return new RegExp('\\\\' + match[0]);\n  }\n}, {\n  name: 'sub-delimiter',\n  pattern: /^(!|&|-|_|\\.|;)/,\n  regex: function regex(match) {\n    return new RegExp(match[0]);\n  }\n}, {\n  name: 'fragment',\n  pattern: /^([0-9a-zA-Z]+)/,\n  regex: function regex(match) {\n    return new RegExp(match[0]);\n  }\n}];\n\nvar tokenise = function tokenise(str, tokens) {\n  if (tokens === void 0) {\n    tokens = [];\n  } // Look for a matching rule\n\n\n  var matched = rules.some(function (rule) {\n    var match = str.match(rule.pattern);\n\n    if (!match) {\n      return false;\n    }\n\n    tokens.push({\n      type: rule.name,\n      match: match[0],\n      val: match.slice(1, 2),\n      otherVal: match.slice(2),\n      regex: rule.regex instanceof Function ? rule.regex(match) : rule.regex\n    });\n\n    if (match[0].length < str.length) {\n      tokens = tokenise(str.substr(match[0].length), tokens);\n    }\n\n    return true;\n  }); // If no rules matched, throw an error (possible malformed path)\n\n  if (!matched) {\n    throw new Error(\"Could not parse path '\" + str + \"'\");\n  }\n\n  return tokens;\n};\n\nvar exists = function exists(val) {\n  return val !== undefined && val !== null;\n};\n\nvar optTrailingSlash = function optTrailingSlash(source, strictTrailingSlash) {\n  if (strictTrailingSlash) {\n    return source;\n  }\n\n  if (source === '\\\\/') {\n    return source;\n  }\n\n  return source.replace(/\\\\\\/$/, '') + '(?:\\\\/)?';\n};\n\nvar upToDelimiter = function upToDelimiter(source, delimiter) {\n  if (!delimiter) {\n    return source;\n  }\n\n  return /(\\/)$/.test(source) ? source : source + '(\\\\/|\\\\?|\\\\.|;|$)';\n};\n\nvar appendQueryParam = function appendQueryParam(params, param, val) {\n  if (val === void 0) {\n    val = '';\n  }\n\n  var existingVal = params[param];\n\n  if (existingVal === undefined) {\n    params[param] = val;\n  } else {\n    params[param] = Array.isArray(existingVal) ? existingVal.concat(val) : [existingVal, val];\n  }\n\n  return params;\n};\n\nvar defaultOptions = {\n  urlParamsEncoding: 'default'\n};\n\nvar Path =\n/*#__PURE__*/\n\n/** @class */\nfunction () {\n  function Path(path, options) {\n    if (!path) {\n      throw new Error('Missing path in Path constructor');\n    }\n\n    this.path = path;\n    this.options = __assign(__assign({}, defaultOptions), options);\n    this.tokens = tokenise(path);\n    this.hasUrlParams = this.tokens.filter(function (t) {\n      return /^url-parameter/.test(t.type);\n    }).length > 0;\n    this.hasSpatParam = this.tokens.filter(function (t) {\n      return /splat$/.test(t.type);\n    }).length > 0;\n    this.hasMatrixParams = this.tokens.filter(function (t) {\n      return /matrix$/.test(t.type);\n    }).length > 0;\n    this.hasQueryParams = this.tokens.filter(function (t) {\n      return /^query-parameter/.test(t.type);\n    }).length > 0; // Extract named parameters from tokens\n\n    this.spatParams = this.getParams('url-parameter-splat');\n    this.urlParams = this.getParams(/^url-parameter/); // Query params\n\n    this.queryParams = this.getParams('query-parameter'); // All params\n\n    this.params = this.urlParams.concat(this.queryParams); // Check if hasQueryParams\n    // Regular expressions for url part only (full and partial match)\n\n    this.source = this.tokens.filter(function (t) {\n      return t.regex !== undefined;\n    }).map(function (t) {\n      return t.regex.source;\n    }).join('');\n  }\n\n  Path.createPath = function (path, options) {\n    return new Path(path, options);\n  };\n\n  Path.prototype.isQueryParam = function (name) {\n    return this.queryParams.indexOf(name) !== -1;\n  };\n\n  Path.prototype.isSpatParam = function (name) {\n    return this.spatParams.indexOf(name) !== -1;\n  };\n\n  Path.prototype.test = function (path, opts) {\n    var _this = this;\n\n    var options = __assign(__assign({\n      caseSensitive: false,\n      strictTrailingSlash: false\n    }, this.options), opts); // trailingSlash: falsy => non optional, truthy => optional\n\n\n    var source = optTrailingSlash(this.source, options.strictTrailingSlash); // Check if exact match\n\n    var match = this.urlTest(path, source + (this.hasQueryParams ? '(\\\\?.*$|$)' : '$'), options.caseSensitive, options.urlParamsEncoding); // If no match, or no query params, no need to go further\n\n    if (!match || !this.hasQueryParams) {\n      return match;\n    } // Extract query params\n\n\n    var queryParams = parse(path, options.queryParams);\n    var unexpectedQueryParams = Object.keys(queryParams).filter(function (p) {\n      return !_this.isQueryParam(p);\n    });\n\n    if (unexpectedQueryParams.length === 0) {\n      // Extend url match\n      Object.keys(queryParams).forEach( // @ts-ignore\n      function (p) {\n        return match[p] = queryParams[p];\n      });\n      return match;\n    }\n\n    return null;\n  };\n\n  Path.prototype.partialTest = function (path, opts) {\n    var _this = this;\n\n    var options = __assign(__assign({\n      caseSensitive: false,\n      delimited: true\n    }, this.options), opts); // Check if partial match (start of given path matches regex)\n    // trailingSlash: falsy => non optional, truthy => optional\n\n\n    var source = upToDelimiter(this.source, options.delimited);\n    var match = this.urlTest(path, source, options.caseSensitive, options.urlParamsEncoding);\n\n    if (!match) {\n      return match;\n    }\n\n    if (!this.hasQueryParams) {\n      return match;\n    }\n\n    var queryParams = parse(path, options.queryParams);\n    Object.keys(queryParams).filter(function (p) {\n      return _this.isQueryParam(p);\n    }).forEach(function (p) {\n      return appendQueryParam(match, p, queryParams[p]);\n    });\n    return match;\n  };\n\n  Path.prototype.build = function (params, opts) {\n    var _this = this;\n\n    if (params === void 0) {\n      params = {};\n    }\n\n    var options = __assign(__assign({\n      ignoreConstraints: false,\n      ignoreSearch: false,\n      queryParams: {}\n    }, this.options), opts);\n\n    var encodedUrlParams = Object.keys(params).filter(function (p) {\n      return !_this.isQueryParam(p);\n    }).reduce(function (acc, key) {\n      if (!exists(params[key])) {\n        return acc;\n      }\n\n      var val = params[key];\n\n      var isSpatParam = _this.isSpatParam(key);\n\n      if (typeof val === 'boolean') {\n        acc[key] = val;\n      } else if (Array.isArray(val)) {\n        acc[key] = val.map(function (v) {\n          return encodeParam(v, options.urlParamsEncoding, isSpatParam);\n        });\n      } else {\n        acc[key] = encodeParam(val, options.urlParamsEncoding, isSpatParam);\n      }\n\n      return acc;\n    }, {}); // Check all params are provided (not search parameters which are optional)\n\n    if (this.urlParams.some(function (p) {\n      return !exists(params[p]);\n    })) {\n      var missingParameters = this.urlParams.filter(function (p) {\n        return !exists(params[p]);\n      });\n      throw new Error(\"Cannot build path: '\" + this.path + \"' requires missing parameters { \" + missingParameters.join(', ') + ' }');\n    } // Check constraints\n\n\n    if (!options.ignoreConstraints) {\n      var constraintsPassed = this.tokens.filter(function (t) {\n        return /^url-parameter/.test(t.type) && !/-splat$/.test(t.type);\n      }).every(function (t) {\n        return new RegExp('^' + defaultOrConstrained(t.otherVal[0]) + '$').test(encodedUrlParams[t.val]);\n      });\n\n      if (!constraintsPassed) {\n        throw new Error(\"Some parameters of '\" + this.path + \"' are of invalid format\");\n      }\n    }\n\n    var base = this.tokens.filter(function (t) {\n      return /^query-parameter/.test(t.type) === false;\n    }).map(function (t) {\n      if (t.type === 'url-parameter-matrix') {\n        return \";\" + t.val + \"=\" + encodedUrlParams[t.val[0]];\n      }\n\n      return /^url-parameter/.test(t.type) ? encodedUrlParams[t.val[0]] : t.match;\n    }).join('');\n\n    if (options.ignoreSearch) {\n      return base;\n    }\n\n    var searchParams = this.queryParams.filter(function (p) {\n      return Object.keys(params).indexOf(p) !== -1;\n    }).reduce(function (sparams, paramName) {\n      sparams[paramName] = params[paramName];\n      return sparams;\n    }, {});\n    var searchPart = build(searchParams, options.queryParams);\n    return searchPart ? base + '?' + searchPart : base;\n  };\n\n  Path.prototype.getParams = function (type) {\n    var predicate = type instanceof RegExp ? function (t) {\n      return type.test(t.type);\n    } : function (t) {\n      return t.type === type;\n    };\n    return this.tokens.filter(predicate).map(function (t) {\n      return t.val[0];\n    });\n  };\n\n  Path.prototype.urlTest = function (path, source, caseSensitive, urlParamsEncoding) {\n    var _this = this;\n\n    var regex = new RegExp('^' + source, caseSensitive ? '' : 'i');\n    var match = path.match(regex);\n\n    if (!match) {\n      return null;\n    } else if (!this.urlParams.length) {\n      return {};\n    } // Reduce named params to key-value pairs\n\n\n    return match.slice(1, this.urlParams.length + 1).reduce(function (params, m, i) {\n      params[_this.urlParams[i]] = decodeParam(m, urlParamsEncoding);\n      return params;\n    }, {});\n  };\n\n  return Path;\n}();\n\nexport { Path };","map":{"version":3,"sources":["../src/encoding.ts","../src/rules.ts","../src/tokeniser.ts","../src/Path.ts"],"names":["excludeSubDelimiters","encodeURIComponentExcludingSubDelims","encodeURIComponent","encodingMethods","uri","uriComponent","none","val","legacy","encodeURI","decodingMethods","decodeURIComponent","encodeParam","encoder","String","decodeParam","defaultOrConstrained","match","rules","name","pattern","regex","tokenise","tokens","matched","str","rule","type","otherVal","exists","optTrailingSlash","source","upToDelimiter","appendQueryParam","existingVal","params","Array","defaultOptions","urlParamsEncoding","Path","t","options","__assign","caseSensitive","strictTrailingSlash","queryParams","parseQueryParams","unexpectedQueryParams","_this","Object","p","delimited","ignoreConstraints","ignoreSearch","encodedUrlParams","isSpatParam","acc","missingParameters","constraintsPassed","base","searchParams","sparams","searchPart","buildQueryParams","predicate","path"],"mappings":"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","sourcesContent":["/**\n * We encode using encodeURIComponent but we want to\n * preserver certain characters which are commonly used\n * (sub delimiters and ':')\n * \n * https://www.ietf.org/rfc/rfc3986.txt\n * \n * reserved    = gen-delims / sub-delims\n * \n * gen-delims  = \":\" / \"/\" / \"?\" / \"#\" / \"[\" / \"]\" / \"@\"\n * \n * sub-delims  = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n              / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n */\n\nconst excludeSubDelimiters = /[^!$'()*+,;|:]/g\n\nexport type URLParamsEncodingType =\n  | 'default'\n  | 'uri'\n  | 'uriComponent'\n  | 'none'\n  | 'legacy'\n\nexport const encodeURIComponentExcludingSubDelims = (segment: string): string =>\n  segment.replace(excludeSubDelimiters, match => encodeURIComponent(match))\n\nconst encodingMethods: Record<\n  URLParamsEncodingType,\n  (param: string) => string\n> = {\n  default: encodeURIComponentExcludingSubDelims,\n  uri: encodeURI,\n  uriComponent: encodeURIComponent,\n  none: val => val,\n  legacy: encodeURI\n}\n\nconst decodingMethods: Record<\n  URLParamsEncodingType,\n  (param: string) => string\n> = {\n  default: decodeURIComponent,\n  uri: decodeURI,\n  uriComponent: decodeURIComponent,\n  none: val => val,\n  legacy: decodeURIComponent\n}\n\nexport const encodeParam = (\n  param: string | number | boolean,\n  encoding: URLParamsEncodingType,\n  isSpatParam: boolean\n): string => {\n  const encoder =\n    encodingMethods[encoding] || encodeURIComponentExcludingSubDelims\n\n  if (isSpatParam) {\n    return String(param)\n      .split('/')\n      .map(encoder)\n      .join('/')\n  }\n\n  return encoder(String(param))\n}\n\nexport const decodeParam = (\n  param: string,\n  encoding: URLParamsEncodingType\n): string => (decodingMethods[encoding] || decodeURIComponent)(param)\n","export const defaultOrConstrained = (match: string): string =>\n  '(' +\n  (match ? match.replace(/(^<|>$)/g, '') : \"[a-zA-Z0-9-_.~%':|=+\\\\*@$]+\") +\n  ')'\n\nexport type RegExpFactory = (match: any) => RegExp\n\nexport interface IRule {\n  /* The name of the rule */\n  name: string\n  /* The regular expression used to find a token in a path definition */\n  pattern: RegExp\n  /* The derived regular expression to match a path */\n  regex?: RegExp | RegExpFactory\n}\n\nconst rules: IRule[] = [\n  {\n    name: 'url-parameter',\n    pattern: /^:([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})(<(.+?)>)?/,\n    regex: (match: RegExpMatchArray) =>\n      new RegExp(defaultOrConstrained(match[2]))\n  },\n  {\n    name: 'url-parameter-splat',\n    pattern: /^\\*([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})/,\n    regex: /([^?]*)/\n  },\n  {\n    name: 'url-parameter-matrix',\n    pattern: /^;([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})(<(.+?)>)?/,\n    regex: (match: RegExpMatchArray) =>\n      new RegExp(';' + match[1] + '=' + defaultOrConstrained(match[2]))\n  },\n  {\n    name: 'query-parameter',\n    pattern: /^(?:\\?|&)(?::)?([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})/\n  },\n  {\n    name: 'delimiter',\n    pattern: /^(\\/|\\?)/,\n    regex: (match: RegExpMatchArray) => new RegExp('\\\\' + match[0])\n  },\n  {\n    name: 'sub-delimiter',\n    pattern: /^(!|&|-|_|\\.|;)/,\n    regex: (match: RegExpMatchArray) => new RegExp(match[0])\n  },\n  {\n    name: 'fragment',\n    pattern: /^([0-9a-zA-Z]+)/,\n    regex: (match: RegExpMatchArray) => new RegExp(match[0])\n  }\n]\n\nexport default rules\n","import rules from './rules'\n\nexport interface Token {\n  type: string\n  match: string\n  val: any\n  otherVal: any\n  regex?: RegExp\n}\n\nconst tokenise = (str: string, tokens: Token[] = []): Token[] => {\n  // Look for a matching rule\n  const matched = rules.some(rule => {\n    const match = str.match(rule.pattern)\n    if (!match) {\n      return false\n    }\n\n    tokens.push({\n      type: rule.name,\n      match: match[0],\n      val: match.slice(1, 2),\n      otherVal: match.slice(2),\n      regex: rule.regex instanceof Function ? rule.regex(match) : rule.regex\n    })\n\n    if (match[0].length < str.length) {\n      tokens = tokenise(str.substr(match[0].length), tokens)\n    }\n    return true\n  })\n\n  // If no rules matched, throw an error (possible malformed path)\n  if (!matched) {\n    throw new Error(`Could not parse path '${str}'`)\n  }\n\n  return tokens\n}\n\nexport default tokenise\n","import {\n  build as buildQueryParams,\n  IOptions,\n  parse as parseQueryParams\n} from 'search-params'\n\nimport { URLParamsEncodingType, decodeParam, encodeParam } from './encoding'\nimport { defaultOrConstrained } from './rules'\nimport tokenise, { Token } from './tokeniser'\n\nexport { URLParamsEncodingType }\n\nconst exists = (val: any) => val !== undefined && val !== null\n\nconst optTrailingSlash = (source: string, strictTrailingSlash: boolean) => {\n  if (strictTrailingSlash) {\n    return source\n  }\n\n  if (source === '\\\\/') {\n    return source\n  }\n\n  return source.replace(/\\\\\\/$/, '') + '(?:\\\\/)?'\n}\n\nconst upToDelimiter = (source: string, delimiter?: boolean) => {\n  if (!delimiter) {\n    return source\n  }\n\n  return /(\\/)$/.test(source) ? source : source + '(\\\\/|\\\\?|\\\\.|;|$)'\n}\n\nconst appendQueryParam = (\n  params: Record<string, any>,\n  param: string,\n  val = ''\n) => {\n  const existingVal = params[param]\n\n  if (existingVal === undefined) {\n    params[param] = val\n  } else {\n    params[param] = Array.isArray(existingVal)\n      ? existingVal.concat(val)\n      : [existingVal, val]\n  }\n\n  return params\n}\n\nexport interface PathOptions {\n  /**\n   * Query parameters buiding and matching options, see\n   * https://github.com/troch/search-params#options\n   */\n  queryParams?: IOptions\n  /**\n   * Specifies the method used to encode URL parameters:\n   *   - `'default': `encodeURIComponent` and `decodeURIComponent`\n   *      are used but some characters to encode and decode URL parameters,\n   *      but some characters are preserved when encoding\n   *      (sub-delimiters: `+`, `:`, `'`, `!`, `,`, `;`, `'*'`).\n   *   - `'uriComponent'`: use `encodeURIComponent` and `decodeURIComponent`\n   *      for encoding and decoding URL parameters.\n   *   - `'uri'`: use `encodeURI` and `decodeURI for encoding amd decoding\n   *      URL parameters.\n   *   - `'none'`: no encoding or decoding is performed\n   *   - `'legacy'`: the approach for version 5.x and below (not recoomended)\n   */\n  urlParamsEncoding?: URLParamsEncodingType\n}\n\nexport interface InternalPathOptions {\n  queryParams?: IOptions\n  urlParamsEncoding: URLParamsEncodingType\n}\n\nconst defaultOptions: InternalPathOptions = {\n  urlParamsEncoding: 'default'\n}\n\nexport interface PathPartialTestOptions extends PathOptions {\n  caseSensitive?: boolean\n  delimited?: boolean\n}\n\nexport interface PathTestOptions extends PathOptions {\n  caseSensitive?: boolean\n  strictTrailingSlash?: boolean\n}\n\nexport interface PathBuildOptions extends PathOptions {\n  ignoreConstraints?: boolean\n  ignoreSearch?: boolean\n}\n\nexport type TestMatch<\n  T extends Record<string, any> = Record<string, any>\n> = T | null\n\nexport class Path<T extends Record<string, any> = Record<string, any>> {\n  public static createPath<T extends Record<string, any> = Record<string, any>>(\n    path: string,\n    options?: PathOptions\n  ) {\n    return new Path<T>(path, options)\n  }\n\n  public path: string\n  public tokens: Token[]\n  public hasUrlParams: boolean\n  public hasSpatParam: boolean\n  public hasMatrixParams: boolean\n  public hasQueryParams: boolean\n  public options: InternalPathOptions\n  public spatParams: string[]\n  public urlParams: string[]\n  public queryParams: string[]\n  public params: string[]\n  public source: string\n\n  constructor(path: string, options?: PathOptions) {\n    if (!path) {\n      throw new Error('Missing path in Path constructor')\n    }\n    this.path = path\n    this.options = {\n      ...defaultOptions,\n      ...options\n    }\n    this.tokens = tokenise(path)\n\n    this.hasUrlParams =\n      this.tokens.filter(t => /^url-parameter/.test(t.type)).length > 0\n    this.hasSpatParam =\n      this.tokens.filter(t => /splat$/.test(t.type)).length > 0\n    this.hasMatrixParams =\n      this.tokens.filter(t => /matrix$/.test(t.type)).length > 0\n    this.hasQueryParams =\n      this.tokens.filter(t => /^query-parameter/.test(t.type)).length > 0\n    // Extract named parameters from tokens\n    this.spatParams = this.getParams('url-parameter-splat')\n    this.urlParams = this.getParams(/^url-parameter/)\n    // Query params\n    this.queryParams = this.getParams('query-parameter')\n    // All params\n    this.params = this.urlParams.concat(this.queryParams)\n    // Check if hasQueryParams\n    // Regular expressions for url part only (full and partial match)\n    this.source = this.tokens\n      .filter(t => t.regex !== undefined)\n      .map(t => t.regex!.source)\n      .join('')\n  }\n\n  public isQueryParam(name: string): boolean {\n    return this.queryParams.indexOf(name) !== -1\n  }\n\n  public isSpatParam(name: string): boolean {\n    return this.spatParams.indexOf(name) !== -1\n  }\n\n  public test(path: string, opts?: PathTestOptions): TestMatch<T> {\n    const options = {\n      caseSensitive: false,\n      strictTrailingSlash: false,\n      ...this.options,\n      ...opts\n    } as const\n    // trailingSlash: falsy => non optional, truthy => optional\n    const source = optTrailingSlash(this.source, options.strictTrailingSlash)\n    // Check if exact match\n    const match = this.urlTest(\n      path,\n      source + (this.hasQueryParams ? '(\\\\?.*$|$)' : '$'),\n      options.caseSensitive,\n      options.urlParamsEncoding\n    )\n    // If no match, or no query params, no need to go further\n    if (!match || !this.hasQueryParams) {\n      return match\n    }\n    // Extract query params\n    const queryParams = parseQueryParams(path, options.queryParams)\n    const unexpectedQueryParams = Object.keys(queryParams).filter(\n      p => !this.isQueryParam(p)\n    )\n\n    if (unexpectedQueryParams.length === 0) {\n      // Extend url match\n      Object.keys(queryParams).forEach(\n        // @ts-ignore\n        p => (match[p] = (queryParams as any)[p])\n      )\n\n      return match\n    }\n\n    return null\n  }\n\n  public partialTest(\n    path: string,\n    opts?: PathPartialTestOptions\n  ): TestMatch<T> {\n    const options = {\n      caseSensitive: false,\n      delimited: true,\n      ...this.options,\n      ...opts\n    } as const\n    // Check if partial match (start of given path matches regex)\n    // trailingSlash: falsy => non optional, truthy => optional\n    const source = upToDelimiter(this.source, options.delimited)\n    const match = this.urlTest(\n      path,\n      source,\n      options.caseSensitive,\n      options.urlParamsEncoding\n    )\n\n    if (!match) {\n      return match\n    }\n\n    if (!this.hasQueryParams) {\n      return match\n    }\n\n    const queryParams = parseQueryParams(path, options.queryParams)\n\n    Object.keys(queryParams)\n      .filter(p => this.isQueryParam(p))\n      .forEach(p => appendQueryParam(match, p, (queryParams as any)[p]))\n\n    return match\n  }\n\n  public build(params: T = {} as T, opts?: PathBuildOptions): string {\n    const options = {\n      ignoreConstraints: false,\n      ignoreSearch: false,\n      queryParams: {},\n      ...this.options,\n      ...opts\n    } as const\n    const encodedUrlParams = Object.keys(params)\n      .filter(p => !this.isQueryParam(p))\n      .reduce<Record<string, any>>((acc, key) => {\n        if (!exists(params[key])) {\n          return acc\n        }\n\n        const val = params[key]\n        const isSpatParam = this.isSpatParam(key)\n\n        if (typeof val === 'boolean') {\n          acc[key] = val\n        } else if (Array.isArray(val)) {\n          acc[key] = val.map(v =>\n            encodeParam(v, options.urlParamsEncoding, isSpatParam)\n          )\n        } else {\n          acc[key] = encodeParam(val, options.urlParamsEncoding, isSpatParam)\n        }\n\n        return acc\n      }, {})\n\n    // Check all params are provided (not search parameters which are optional)\n    if (this.urlParams.some(p => !exists(params[p]))) {\n      const missingParameters = this.urlParams.filter(p => !exists(params[p]))\n      throw new Error(\n        \"Cannot build path: '\" +\n          this.path +\n          \"' requires missing parameters { \" +\n          missingParameters.join(', ') +\n          ' }'\n      )\n    }\n\n    // Check constraints\n    if (!options.ignoreConstraints) {\n      const constraintsPassed = this.tokens\n        .filter(t => /^url-parameter/.test(t.type) && !/-splat$/.test(t.type))\n        .every(t =>\n          new RegExp('^' + defaultOrConstrained(t.otherVal[0]) + '$').test(\n            encodedUrlParams[t.val]\n          )\n        )\n\n      if (!constraintsPassed) {\n        throw new Error(\n          `Some parameters of '${this.path}' are of invalid format`\n        )\n      }\n    }\n\n    const base = this.tokens\n      .filter(t => /^query-parameter/.test(t.type) === false)\n      .map(t => {\n        if (t.type === 'url-parameter-matrix') {\n          return `;${t.val}=${encodedUrlParams[t.val[0]]}`\n        }\n\n        return /^url-parameter/.test(t.type)\n          ? encodedUrlParams[t.val[0]]\n          : t.match\n      })\n      .join('')\n\n    if (options.ignoreSearch) {\n      return base\n    }\n\n    const searchParams = this.queryParams\n      .filter(p => Object.keys(params).indexOf(p) !== -1)\n      .reduce<Record<string, any>>((sparams, paramName) => {\n        sparams[paramName] = params[paramName]\n        return sparams\n      }, {})\n    const searchPart = buildQueryParams(searchParams, options.queryParams)\n\n    return searchPart ? base + '?' + searchPart : base\n  }\n\n  private getParams(type: string | RegExp): string[] {\n    const predicate =\n      type instanceof RegExp\n        ? (t: Token) => type.test(t.type)\n        : (t: Token) => t.type === type\n\n    return this.tokens.filter(predicate).map(t => t.val[0])\n  }\n\n  private urlTest(\n    path: string,\n    source: string,\n    caseSensitive: boolean,\n    urlParamsEncoding: URLParamsEncodingType\n  ): TestMatch<T> {\n    const regex = new RegExp('^' + source, caseSensitive ? '' : 'i')\n    const match = path.match(regex)\n    if (!match) {\n      return null\n    } else if (!this.urlParams.length) {\n      return {} as T\n    }\n    // Reduce named params to key-value pairs\n    return match\n      .slice(1, this.urlParams.length + 1)\n      .reduce<Record<string, any>>((params, m, i) => {\n        params[this.urlParams[i]] = decodeParam(m, urlParamsEncoding)\n        return params\n      }, {}) as T\n  }\n}\n\nexport default Path\n"]},"metadata":{},"sourceType":"module"}