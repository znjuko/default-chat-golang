{"ast":null,"code":"var makeOptions = function makeOptions(opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  return {\n    arrayFormat: opts.arrayFormat || 'none',\n    booleanFormat: opts.booleanFormat || 'none',\n    nullFormat: opts.nullFormat || 'default'\n  };\n};\n\nvar encodeValue = function encodeValue(value) {\n  return encodeURIComponent(value);\n};\n\nvar decodeValue = function decodeValue(value) {\n  return decodeURIComponent(value);\n};\n\nvar encodeBoolean = function encodeBoolean(name, value, opts) {\n  if (opts.booleanFormat === 'empty-true' && value) {\n    return name;\n  }\n\n  var encodedValue;\n\n  if (opts.booleanFormat === 'unicode') {\n    encodedValue = value ? '✓' : '✗';\n  } else {\n    encodedValue = value.toString();\n  }\n\n  return name + \"=\" + encodedValue;\n};\n\nvar encodeNull = function encodeNull(name, opts) {\n  if (opts.nullFormat === 'hidden') {\n    return '';\n  }\n\n  if (opts.nullFormat === 'string') {\n    return name + \"=null\";\n  }\n\n  return name;\n};\n\nvar getNameEncoder = function getNameEncoder(opts) {\n  if (opts.arrayFormat === 'index') {\n    return function (name, index) {\n      return name + \"[\" + index + \"]\";\n    };\n  }\n\n  if (opts.arrayFormat === 'brackets') {\n    return function (name) {\n      return name + \"[]\";\n    };\n  }\n\n  return function (name) {\n    return name;\n  };\n};\n\nvar encodeArray = function encodeArray(name, arr, opts) {\n  var encodeName = getNameEncoder(opts);\n  return arr.map(function (val, index) {\n    return encodeName(name, index) + \"=\" + encodeValue(val);\n  }).join('&');\n};\n\nvar encode = function encode(name, value, opts) {\n  if (value === null) {\n    return encodeNull(name, opts);\n  }\n\n  if (typeof value === 'boolean') {\n    return encodeBoolean(name, value, opts);\n  }\n\n  if (Array.isArray(value)) {\n    return encodeArray(name, value, opts);\n  }\n\n  return name + \"=\" + encodeValue(value);\n};\n\nvar decode = function decode(value, opts) {\n  if (value === undefined) {\n    return opts.booleanFormat === 'empty-true' ? true : null;\n  }\n\n  if (opts.booleanFormat === 'string') {\n    if (value === 'true') {\n      return true;\n    }\n\n    if (value === 'false') {\n      return false;\n    }\n  }\n\n  if (opts.booleanFormat === 'unicode') {\n    if (decodeValue(value) === '✓') {\n      return true;\n    }\n\n    if (decodeValue(value) === '✗') {\n      return false;\n    }\n  }\n\n  if (opts.nullFormat === 'string') {\n    if (value === 'null') {\n      return null;\n    }\n  }\n\n  return decodeValue(value);\n};\n\nvar getSearch = function getSearch(path) {\n  var pos = path.indexOf('?');\n\n  if (pos === -1) {\n    return path;\n  }\n\n  return path.slice(pos + 1);\n};\n\nvar isSerialisable = function isSerialisable(val) {\n  return val !== undefined;\n};\n\nvar parseName = function parseName(name) {\n  var bracketPosition = name.indexOf('[');\n  var hasBrackets = bracketPosition !== -1;\n  return {\n    hasBrackets: hasBrackets,\n    name: hasBrackets ? name.slice(0, bracketPosition) : name\n  };\n};\n/**\r\n * Parse a querystring and return an object of parameters\r\n */\n\n\nvar parse = function parse(path, opts) {\n  var options = makeOptions(opts);\n  return getSearch(path).split('&').reduce(function (params, param) {\n    var _a = param.split('='),\n        rawName = _a[0],\n        value = _a[1];\n\n    var _b = parseName(rawName),\n        hasBrackets = _b.hasBrackets,\n        name = _b.name;\n\n    var currentValue = params[name];\n    var decodedValue = decode(value, options);\n\n    if (currentValue === undefined) {\n      params[name] = hasBrackets ? [decodedValue] : decodedValue;\n    } else {\n      params[name] = (Array.isArray(currentValue) ? currentValue : [currentValue]).concat(decodedValue);\n    }\n\n    return params;\n  }, {});\n};\n/**\r\n * Build a querystring from an object of parameters\r\n */\n\n\nvar build = function build(params, opts) {\n  var options = makeOptions(opts);\n  return Object.keys(params).filter(function (paramName) {\n    return isSerialisable(params[paramName]);\n  }).map(function (paramName) {\n    return encode(paramName, params[paramName], options);\n  }).filter(Boolean).join('&');\n};\n/**\r\n * Remove a list of parameters from a querystring\r\n */\n\n\nvar omit = function omit(path, paramsToOmit, opts) {\n  var options = makeOptions(opts);\n  var searchPart = getSearch(path);\n\n  if (searchPart === '') {\n    return {\n      querystring: '',\n      removedParams: {}\n    };\n  }\n\n  var _a = path.split('&').reduce(function (_a, chunk) {\n    var left = _a[0],\n        right = _a[1];\n    var rawName = chunk.split('=')[0];\n    var name = parseName(rawName).name;\n    return paramsToOmit.indexOf(name) === -1 ? [left.concat(chunk), right] : [left, right.concat(chunk)];\n  }, [[], []]),\n      kept = _a[0],\n      removed = _a[1];\n\n  return {\n    querystring: kept.join('&'),\n    removedParams: parse(removed.join('&'), options)\n  };\n};\n/**\r\n * Remove a list of parameters from a querystring\r\n */\n\n\nvar keep = function keep(path, paramsToKeep, opts) {\n  var options = makeOptions(opts);\n  var searchPart = getSearch(path);\n\n  if (searchPart === '') {\n    return {\n      keptParams: {},\n      querystring: ''\n    };\n  }\n\n  var kept = path.split('&').reduce(function (acc, chunk) {\n    var rawName = chunk.split('=')[0];\n    var name = parseName(rawName).name;\n\n    if (paramsToKeep.includes(name)) {\n      acc.push(chunk);\n    }\n\n    return acc;\n  }, []);\n  return {\n    keptParams: parse(kept.join('&'), options),\n    querystring: kept.join('&')\n  };\n};\n\nexport { build, keep, omit, parse };","map":{"version":3,"sources":["../src/encode.ts","../src/utils.ts","../src/index.ts"],"names":["makeOptions","opts","arrayFormat","booleanFormat","nullFormat","encodeValue","encodeURIComponent","decodeValue","decodeURIComponent","encodeBoolean","encodedValue","value","name","encodeNull","getNameEncoder","encodeArray","encodeName","encode","Array","decode","getSearch","pos","path","isSerialisable","val","parseName","bracketPosition","hasBrackets","parse","options","_a","rawName","_b","currentValue","params","decodedValue","build","omit","searchPart","querystring","removedParams","kept","removed","keep","keptParams","chunk","paramsToKeep","acc"],"mappings":"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","sourcesContent":["export type arrayFormat = 'none' | 'brackets' | 'index'\nexport type booleanFormat = 'none' | 'string' | 'unicode' | 'empty-true'\nexport type nullFormat = 'default' | 'string' | 'hidden'\n\nexport interface IOptions {\n  arrayFormat?: arrayFormat\n  booleanFormat?: booleanFormat\n  nullFormat?: nullFormat\n}\n\nexport interface IFinalOptions {\n  arrayFormat: arrayFormat\n  booleanFormat: booleanFormat\n  nullFormat: nullFormat\n}\n\nexport const makeOptions = (opts: IOptions = {}): IFinalOptions => ({\n  arrayFormat: opts.arrayFormat || 'none',\n  booleanFormat: opts.booleanFormat || 'none',\n  nullFormat: opts.nullFormat || 'default'\n})\n\nconst encodeValue = (value: any): string => encodeURIComponent(value)\n\nconst decodeValue = (value: string): string => decodeURIComponent(value)\n\nconst encodeBoolean = (\n  name: string,\n  value: boolean,\n  opts: IFinalOptions\n): string => {\n  if (opts.booleanFormat === 'empty-true' && value) {\n    return name\n  }\n\n  let encodedValue\n\n  if (opts.booleanFormat === 'unicode') {\n    encodedValue = value ? '✓' : '✗'\n  } else {\n    encodedValue = value.toString()\n  }\n\n  return `${name}=${encodedValue}`\n}\n\nconst encodeNull = (name: string, opts: IFinalOptions): string => {\n  if (opts.nullFormat === 'hidden') {\n    return ''\n  }\n\n  if (opts.nullFormat === 'string') {\n    return `${name}=null`\n  }\n\n  return name\n}\n\ntype nameEncoder = (val: string, index: number) => string\n\nconst getNameEncoder = (opts: IFinalOptions): nameEncoder => {\n  if (opts.arrayFormat === 'index') {\n    return (name: string, index: number): string => `${name}[${index}]`\n  }\n\n  if (opts.arrayFormat === 'brackets') {\n    return (name: string): string => `${name}[]`\n  }\n\n  return (name: string): string => name\n}\n\nexport const encodeArray = (\n  name: string,\n  arr: any[],\n  opts: IFinalOptions\n): string => {\n  const encodeName = getNameEncoder(opts)\n\n  return arr\n    .map((val, index) => `${encodeName(name, index)}=${encodeValue(val)}`)\n    .join('&')\n}\n\nexport const encode = (\n  name: string,\n  value: any,\n  opts: IFinalOptions\n): string => {\n  if (value === null) {\n    return encodeNull(name, opts)\n  }\n\n  if (typeof value === 'boolean') {\n    return encodeBoolean(name, value, opts)\n  }\n\n  if (Array.isArray(value)) {\n    return encodeArray(name, value, opts)\n  }\n\n  return `${name}=${encodeValue(value)}`\n}\n\nexport const decode = (\n  value: any,\n  opts: IFinalOptions\n): boolean | string | null => {\n  if (value === undefined) {\n    return opts.booleanFormat === 'empty-true' ? true : null\n  }\n\n  if (opts.booleanFormat === 'string') {\n    if (value === 'true') {\n      return true\n    }\n    if (value === 'false') {\n      return false\n    }\n  }\n\n  if (opts.booleanFormat === 'unicode') {\n    if (decodeValue(value) === '✓') {\n      return true\n    }\n    if (decodeValue(value) === '✗') {\n      return false\n    }\n  }\n\n  if (opts.nullFormat === 'string') {\n    if (value === 'null') {\n      return null\n    }\n  }\n\n  return decodeValue(value)\n}\n","export const getSearch = (path: string): string => {\n  const pos = path.indexOf('?')\n\n  if (pos === -1) {\n    return path\n  }\n\n  return path.slice(pos + 1)\n}\n\nexport const isSerialisable = (val: any): boolean => val !== undefined\n\nexport interface IParsedName {\n  hasBrackets: boolean\n  name: string\n}\n\nexport const parseName = (name: string): IParsedName => {\n  const bracketPosition = name.indexOf('[')\n  const hasBrackets = bracketPosition !== -1\n\n  return {\n    hasBrackets,\n    name: hasBrackets ? name.slice(0, bracketPosition) : name\n  }\n}\n","import { decode, encode, IOptions, makeOptions } from './encode'\nimport { getSearch, isSerialisable, parseName } from './utils'\n\nexport { IOptions }\n\nexport type SearchParams = Record<\n  string,\n  string | boolean | null | Array<string | boolean | null> | undefined\n>\n\n/**\n * Parse a querystring and return an object of parameters\n */\nexport const parse = <T extends Record<string, any> = SearchParams>(\n  path: string,\n  opts?: IOptions\n): T => {\n  const options = makeOptions(opts)\n\n  return getSearch(path)\n    .split('&')\n    .reduce<Record<string, any>>((params, param) => {\n      const [rawName, value] = param.split('=')\n      const { hasBrackets, name } = parseName(rawName)\n      const currentValue = params[name]\n      const decodedValue = decode(value, options)\n\n      if (currentValue === undefined) {\n        params[name] = hasBrackets ? [decodedValue] : decodedValue\n      } else {\n        params[name] = (Array.isArray(currentValue)\n          ? currentValue\n          : [currentValue]\n        ).concat(decodedValue)\n      }\n\n      return params\n    }, {}) as T\n}\n\n/**\n * Build a querystring from an object of parameters\n */\nexport const build = <T extends Record<string, any> = SearchParams>(\n  params: T,\n  opts?: IOptions\n): string => {\n  const options = makeOptions(opts)\n\n  return Object.keys(params)\n    .filter(paramName => isSerialisable(params[paramName]))\n    .map(paramName => encode(paramName, params[paramName], options))\n    .filter(Boolean)\n    .join('&')\n}\n\nexport interface IOmitResponse {\n  querystring: string\n  removedParams: object\n}\n\n/**\n * Remove a list of parameters from a querystring\n */\nexport const omit = (\n  path: string,\n  paramsToOmit: string[],\n  opts?: IOptions\n): IOmitResponse => {\n  const options = makeOptions(opts)\n  const searchPart = getSearch(path)\n  if (searchPart === '') {\n    return {\n      querystring: '',\n      removedParams: {}\n    }\n  }\n\n  const [kept, removed] = path.split('&').reduce<[string[], string[]]>(\n    ([left, right]: [string[], string[]], chunk: string) => {\n      const rawName = chunk.split('=')[0]\n      const { name } = parseName(rawName)\n\n      return paramsToOmit.indexOf(name) === -1\n        ? [left.concat(chunk), right]\n        : [left, right.concat(chunk)]\n    },\n    [[], []]\n  )\n\n  return {\n    querystring: kept.join('&'),\n    removedParams: parse(removed.join('&'), options)\n  }\n}\n\nexport interface IKeepResponse {\n  querystring: string\n  keptParams: object\n}\n\n/**\n * Remove a list of parameters from a querystring\n */\nexport const keep = (\n  path: string,\n  paramsToKeep: string[],\n  opts?: IOptions\n): IKeepResponse => {\n  const options = makeOptions(opts)\n  const searchPart = getSearch(path)\n  if (searchPart === '') {\n    return {\n      keptParams: {},\n      querystring: ''\n    }\n  }\n\n  const kept = path.split('&').reduce<string[]>((acc, chunk: string) => {\n    const rawName = chunk.split('=')[0]\n    const { name } = parseName(rawName)\n\n    if (paramsToKeep.includes(name)) {\n      acc.push(chunk)\n    }\n\n    return acc\n  }, [])\n\n  return {\n    keptParams: parse(kept.join('&'), options),\n    querystring: kept.join('&')\n  }\n}\n"]},"metadata":{},"sourceType":"module"}