{"ast":null,"code":"import API from '../utils/API';\nimport { webSocket } from 'rxjs/webSocket';\nexport default async function connectSocket() {\n  try {\n    let res = await API.get('/ws', {\n      params: {\n        results: 1,\n        inc: 'token'\n      }\n    });\n    let token = res.data.token;\n    console.log(res);\n    window.socket = webSocket(`ws://localhost:3000/ws/${token}`);\n    window.socket.subscribe(msg => {\n      console.log('message received: ');\n      console.log(msg);\n    }, // Called whenever there is a message from the server.\n    err => {\n      console.log('[DEBUG]: error with ws: ');\n      console.log(err);\n    }, // Called if at any point WebSocket API signals some kind of error.\n    () => console.log('complete') // Called when connection is closed (for whatever reason).\n    ); // window.socket = new WebSocket(`ws://localhost:3000/ws/${token}`);\n\n    /* window.socket.onopen = function (e) {\n    \tconsole.log('[WS] Соединение установлено');\n    };\n    \twindow.socket.onmessage = function (event) {\n    \tconsole.log('[WS] Message', event);\n    \tvar data = JSON.parse(event.data);\n    \t\tlet newMsg = {\n    \t\tauthor: data.message.author,\n    \t\ttxt: data.message.txt,\n    \t\tchatName: data.message.chatName,\n    \t\tchatId: data.message.chatId,\n    \t\temojies: data.message.emojies,\n    \t};\n    \tobserver.next(newMsg);\n    };\n    \twindow.socket.onclose = function (event) {\n    \tif (event.wasClean) {\n    \t\tconsole.log(\n    \t\t\t`[WS] Соединение закрыто чисто, код=${event.code} причина=${event.reason}`,\n    \t\t);\n    \t} else {\n    \t\tconnectSocket();\n    \t\tconsole.log('[WS] Соединение прервано');\n    \t}\n    };\n    \twindow.socket.onerror = function (error) {\n    \tconsole.error(`[WS] ${error.message}`);\n    }; */\n  } catch (err) {\n    console.error(`[WS] ${err}`);\n  }\n}","map":{"version":3,"sources":["/home/znjuko/Рабочий стол/rk2/bmstu_front/default-chat-golang/front/src/utils/Socket.js"],"names":["API","webSocket","connectSocket","res","get","params","results","inc","token","data","console","log","window","socket","subscribe","msg","err","error"],"mappings":"AAAA,OAAOA,GAAP,MAAgB,cAAhB;AACA,SAASC,SAAT,QAA0B,gBAA1B;AAEA,eAAe,eAAeC,aAAf,GAA+B;AAC7C,MAAI;AACH,QAAIC,GAAG,GAAG,MAAMH,GAAG,CAACI,GAAJ,CAAQ,KAAR,EAAe;AAC9BC,MAAAA,MAAM,EAAE;AACPC,QAAAA,OAAO,EAAE,CADF;AAEPC,QAAAA,GAAG,EAAE;AAFE;AADsB,KAAf,CAAhB;AAMA,QAAIC,KAAK,GAAGL,GAAG,CAACM,IAAJ,CAASD,KAArB;AAEAE,IAAAA,OAAO,CAACC,GAAR,CAAYR,GAAZ;AACAS,IAAAA,MAAM,CAACC,MAAP,GAAgBZ,SAAS,CAAE,0BAAyBO,KAAM,EAAjC,CAAzB;AAEAI,IAAAA,MAAM,CAACC,MAAP,CAAcC,SAAd,CACEC,GAAD,IAAS;AACRL,MAAAA,OAAO,CAACC,GAAR,CAAY,oBAAZ;AACAD,MAAAA,OAAO,CAACC,GAAR,CAAYI,GAAZ;AACA,KAJF,EAII;AACFC,IAAAA,GAAD,IAAS;AACRN,MAAAA,OAAO,CAACC,GAAR,CAAY,0BAAZ;AACAD,MAAAA,OAAO,CAACC,GAAR,CAAYK,GAAZ;AACA,KARF,EAQI;AACH,UAAMN,OAAO,CAACC,GAAR,CAAY,UAAZ,CATP,CASgC;AAThC,MAZG,CAuBH;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCA,GAzDD,CAyDE,OAAOK,GAAP,EAAY;AACbN,IAAAA,OAAO,CAACO,KAAR,CAAe,QAAOD,GAAI,EAA1B;AACA;AACD","sourcesContent":["import API from '../utils/API';\nimport { webSocket } from 'rxjs/webSocket';\n\nexport default async function connectSocket() {\n\ttry {\n\t\tlet res = await API.get('/ws', {\n\t\t\tparams: {\n\t\t\t\tresults: 1,\n\t\t\t\tinc: 'token',\n\t\t\t},\n\t\t});\n\t\tlet token = res.data.token;\n\n\t\tconsole.log(res);\n\t\twindow.socket = webSocket(`ws://localhost:3000/ws/${token}`);\n\n\t\twindow.socket.subscribe(\n\t\t\t(msg) => {\n\t\t\t\tconsole.log('message received: ');\n\t\t\t\tconsole.log(msg);\n\t\t\t}, // Called whenever there is a message from the server.\n\t\t\t(err) => {\n\t\t\t\tconsole.log('[DEBUG]: error with ws: ');\n\t\t\t\tconsole.log(err);\n\t\t\t}, // Called if at any point WebSocket API signals some kind of error.\n\t\t\t() => console.log('complete'), // Called when connection is closed (for whatever reason).\n\t\t);\n\t\t// window.socket = new WebSocket(`ws://localhost:3000/ws/${token}`);\n\n\t\t/* window.socket.onopen = function (e) {\n\t\t\tconsole.log('[WS] Соединение установлено');\n\t\t};\n\n\t\twindow.socket.onmessage = function (event) {\n\t\t\tconsole.log('[WS] Message', event);\n\t\t\tvar data = JSON.parse(event.data);\n\n\t\t\tlet newMsg = {\n\t\t\t\tauthor: data.message.author,\n\t\t\t\ttxt: data.message.txt,\n\t\t\t\tchatName: data.message.chatName,\n\t\t\t\tchatId: data.message.chatId,\n\t\t\t\temojies: data.message.emojies,\n\t\t\t};\n\t\t\tobserver.next(newMsg);\n\t\t};\n\n\t\twindow.socket.onclose = function (event) {\n\t\t\tif (event.wasClean) {\n\t\t\t\tconsole.log(\n\t\t\t\t\t`[WS] Соединение закрыто чисто, код=${event.code} причина=${event.reason}`,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tconnectSocket();\n\t\t\t\tconsole.log('[WS] Соединение прервано');\n\t\t\t}\n\t\t};\n\n\t\twindow.socket.onerror = function (error) {\n\t\t\tconsole.error(`[WS] ${error.message}`);\n\t\t}; */\n\t} catch (err) {\n\t\tconsole.error(`[WS] ${err}`);\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}